""" Lazy Probabilistic Roadmap (PRM) implementation. """

import numpy as np
import time
import warnings

from .planner_base import PathPlannerBase
from ..utils.motion import Path
from ..utils.search_graph import SearchGraph, Node
from ..utils.pose import Pose


class LazyPRMPlannerPolygon:
    """
    Polygon representation based implementation of PRM.
    """

    def __init__(
        self,
        collision_check_step_dist=0.025,
        max_connection_dist=2.0,
        max_nodes=50,
        world=None,
    ):
        """
        Creates an instance of a Lazy PRM planner.

        :param max_nodes: Maximum nodes sampled to build the PRM.
        :type max_nodes: int
        :param world: World object to use in the planner.
        :type world: :class:`pyrobosim.core.world.World`
        """
        # Parameters
        self.max_connection_dist = max_connection_dist
        self.max_nodes = max_nodes
        self.world = world

        # 
        self.construct_graph()

    def construct_graph(self):
        # Create a search graph and sample nodes.
        self.graph = SearchGraph(
            color=[0, 0.4, 0.8], color_alpha=0.25, use_planner=True
        )

        x_bounds, y_bounds = self.world.get_bounds()
        for i in range(self.max_nodes):
            n_sample = self.sample_configuration(x_bounds, y_bounds)
            if not n_sample:
                warnings.warn(f"Could not sample more than {i} nodes")
                break
            self.graph.add_node(Node(pose=n_sample))

        for node in self.graph.nodes:
            for other in self.graph.nodes:
                if node == other:
                    continue;
                distance = node.pose.get_linear_distance(other.pose, ignore_z=True)
                if self.max_connection_dist and (distance <= self.max_connection_dist):
                    self.graph.add_edge(node, other)

    def sample_configuration(self, x_bounds, y_bounds):
        xmin, xmax = x_bounds
        ymin, ymax = y_bounds

        x = (xmax - xmin) * np.random.random() + xmin
        y = (ymax - ymin) * np.random.random() + ymin
        yaw = 2.0 * np.pi * np.random.random()
        pose = Pose(x=x, y=y, z=0.0, yaw=yaw)

        return pose

    def plan(self, start, goal):
        """
        Plans a path from start to goal.

        :param start: Start pose or graph node.
        :type start: :class:`pyrobosim.utils.pose.Pose` /
            :class:`pyrobosim.utils.search_graph.Node`
        :param goal: Goal pose or graph node.
        :type goal: :class:`pyrobosim.utils.pose.Pose` /
            :class:`pyrobosim.utils.search_graph.Node`
        :return: Path from start to goal.
        :rtype: :class:`pyrobosim.utils.motion.Path`
        """
        # Reset the path and time
        self.latest_path = Path()
        return self.latest_path

    def get_graphs(self):
        """
        Returns the graphs generated by the planner, if any.

        :return: List of graphs.
        :rtype: list[:class:`pyrobosim.utils.search_graph.SearchGraph`]
        """
        return [self.graph]


class LazyPRMPlanner(PathPlannerBase):
    """Factory class for Lazy Probabilistic RoadMap path planner."""

    def __init__(self, **planner_config):
        """
        Creates an instance of Lazy PRM planner.
        """
        super().__init__()

        self.impl = None

        if planner_config.get("grid", None):
            raise NotImplementedError("Grid based Lazy PRM is not supported. ")
        else:
            self.impl = LazyPRMPlannerPolygon(**planner_config)

    def plan(self, start, goal):
        """
        Plans a path from start to goal.

        :param start: Start pose.
        :type start: :class:`pyrobosim.utils.pose.Pose`
        :param goal: Goal pose.
        :type goal: :class:`pyrobosim.utils.pose.Pose`
        :return: Path from start to goal.
        :rtype: :class:`pyrobosim.utils.motion.Path`
        """
        start_time = time.time()
        self.latest_path = self.impl.plan(start, goal)
        self.planning_time = time.time() - start_time
        self.graphs = self.impl.get_graphs()
        return self.latest_path
